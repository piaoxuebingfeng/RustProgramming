# 格式化输出



## 格式化打印 println!

  `println!`是一个宏,用于将格式化的字符串打印到控制台中。



打印操作由 [`std::fmt`](https://www.rustwiki.org.cn/zh-CN/std/fmt/) 里面所定义的一系列[宏](https://www.rustwiki.org.cn/zh-CN/rust-by-example/macros.html)来处理，包括：

- `format!`：将格式化文本写到[字符串](https://www.rustwiki.org.cn/zh-CN/rust-by-example/std/str.html)。
- `print!`：与 `format!` 类似，但将文本输出到控制台（io::stdout）。
- `println!`: 与 `print!` 类似，但输出结果追加一个换行符。
- `eprint!`：与 `print!` 类似，但将文本输出到标准错误（io::stderr）。
- `eprintln!`：与 `eprint!` 类似，但输出结果追加一个换行符。

这些宏都以相同的做法解析文本。有个额外优点是**格式化的正确性会在编译时检查**。

```rust
fn main(){
    println!("hello world");
    print!("hello");
    print!(" world");
    
    let teststr=format!("hello world");
    println!("{}",teststr);

    // 通常情况下， `{}` 会被任意变量内容所替换
    println!("{} days",30);
    
    // 用变量替换字符串有多种写法。
    // 比如可以使用位置参数。
    println!("{0}, this is {1}.{1},this is {0}.","Alice","Bob");
    
    // 可以使用命名参数
    println!("{a} ,{b} {c}.",a="hello",b="I am",c="Jox");
    
    // 可以在 ':' 后面指定特殊的格式
    println!("{} of {:b} people know binary,the other half don't."1,2);
  
    // 你可以按指定宽度来右对齐文本。
    // 下面语句输出 "     1"，5 个空格后面连着 1。
    println!("{number:>width$}", number=1, width=6);

    // 你可以在数字左边补 0。下面语句输出 "000001"。
    println!("{number:>0width$}", number=1, width=6);
    
}
```



```rust
fn main(){
    // println! 会检查使用到的参数数量是否正确。
    // 这里需要两个参数，但是代码中指给出一个参数，编译报错
    println!("My name is {0}, {1} {0}", "Bond");
    
}
```



std::fmt 包含多种 trait 来控制文本显示。其中重要的两种 trait 的基本形式是：



- fmt::Debug 使用  `{:?}`标记，格式化为本以供调试使用
- fmt::Display 使用 `{}` 标记，以更优雅和油耗的风格来格式化文本。



在上面的例子中，使用到了 fmt::Display ，在标准库中提供了上对应的变量类型的格式化实现。

如果要打印自定义类型的格式化输出，则需要自己编写对应类型的Display.

在下面的代码中，是无法直接打印出 Structure 结构体的格式化字符串的，这段代码编译会报错。

```rust
fn main(){
    // 创建一个包含单个 `i32` 的结构体（structure）。命名为 `Structure`。
    #[allow(dead_code)]
    struct Structure(i32);

    // 但是像结构体这样的自定义类型需要更复杂的方式来处理。
    // 下面语句无法运行。
    println!("This struct `{}` won't print...", Structure(3));
}
```

后面会实现对结构体的格式化打印输出。



## Display

  手动实现 fmt::Display ，以实现自定义类型的 Display

```rust
use std::fmt;

// `Structure`，包含一个 `i32` 元素
struct Structure(i32);

// 为了让结构体 Structure 使用 `{}` 标记，必须手动为类型实现 `fmt::Display` trait
impl fmt::Display for Structure{
    // 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // 仅将 self 的第一个元素写入到给定的输出流 `f`。返回 `fmt:Result`，此
        // 结果表明操作成功或失败。注意 `write!` 的用法和 `println!` 很相似。
        write!(f, "{}", self.0)
    }
}

```





编写一个程序，定义一个复数结构体，然后打印该结构体中的信息，要求输出格式如下：

```bash
Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
```






```rust
use std::fmt;

#[derive(Debug)]
struct RealImag{
    real:f64,
    imag:f64,
}

impl fmt::Display for RealImag {
    fn fmt(&self,f: &mut fmt::Formatter) -> fmt::Result {
        write!(f,"{} + {}i",self.real,self.imag)
    }
}

fn main()
{
    let test_ri=RealImag {real:3.3,imag:7.2};

    println!("Debug: {:?}",test_ri);
    println!("Display {}",test_ri);

}
```

